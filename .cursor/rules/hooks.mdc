---
description: making hooks
globs: *.tsx, *.ts
alwaysApply: false
---
---
description: Guide for implementing Payload CMS 3.0 hooks
globs: [src/hooks/**/*.ts, src/collections/**/*.ts]
alwaysApply: false
---

# Payload CMS 3.0 Hooks Implementation Guide

## What Are Hooks?

Hooks in Payload CMS are powerful lifecycle methods that allow you to execute custom logic at specific points during document operations (create, read, update, delete). They enable you to transform your CMS from a content storage system into a fully-featured application with custom business logic.

## Types of Hooks in Payload

### Collection Hooks
- `beforeOperation`: Run before any operation
- `beforeValidate`: Run before validation
- `beforeChange`: Run after validation but before saving to the database
- `afterChange`: Run after a document has been created or updated
- `beforeRead`: Run before documents are returned to the requester
- `afterRead`: Run after documents are returned, but before sending to the client
- `beforeDelete`: Run before a document is deleted
- `afterDelete`: Run after a document has been deleted

### Field Hooks
- `beforeValidate`: Run before a field is validated
- `beforeChange`: Run after validation but before a field value is saved
- `afterChange`: Run after a field value has been changed
- `afterRead`: Run after a field is read, allowing transformation of the output

### Global Hooks
- Similar to collection hooks but for global singleton documents

## When to Use Hooks vs Server Actions or Client Components

### Use Payload Hooks When:

✅ **Automating CMS Operations**
- Generating derived content (QR codes, thumbnails, summaries)
- Synchronizing data between collections 
- Enforcing business rules on content changes
- Validating or transforming data before save

✅ **Integrating with External Systems**
- Sending notifications when content changes
- Syncing data to external services
- Registering webhooks

✅ **Content Processing**
- Processing uploaded files (optimizing images, extracting metadata)
- Generating media transformations
- Creating relationships between content

### Use Server Actions or Components When:

❌ **User-Initiated Actions**
- Actions not tied to document lifecycle
- Custom UI workflows
- Operations that need to run without modifying content

❌ **Complex UI Interactions**
- Multi-step processes with UI feedback
- Operations requiring complex user input validation
- Workflows requiring user confirmation

## Directory Structure

Organize hooks following this structure for maintainability:

```
src/hooks/
  collections/      // Collection-specific hooks
    [CollectionName]/
      beforeChange.ts
      afterChange.ts
      etc...
  fields/           // Field-specific hooks
    [FieldType]/
      [hookName].ts
  globals/          // Global hooks
  utils/            // Shared hook utilities
```

## QR Code Generation Example

The following example demonstrates using an `afterChange` hook to automatically generate a QR code when an event is created or updated:

```typescript
// src/hooks/collections/events/afterChange.ts
import QRCode from 'qrcode'
import path from 'path'
import fs from 'fs'
import type { AfterChangeHook } from 'payload'

export const generateQRCode: AfterChangeHook = async ({ doc, req, operation }) => {
  // Only run for create operations or when regeneration is requested
  if (operation === 'create' || doc.qrCodeSettings?.forceRegenerate) {
    try {
      // Setup temporary storage
      const staticDir = path.resolve(__dirname, '../../../media/qrcodes')
      if (!fs.existsSync(staticDir)) {
        fs.mkdirSync(staticDir, { recursive: true })
      }
      
      // Generate QR code
      const filename = `qr-event-${doc.id}.png`
      const filePath = path.join(staticDir, filename)
      const qrSettings = doc.qrCodeSettings || { size: 300 }
      
      await QRCode.toFile(filePath, `https://yourdomain.com/events/${doc.slug}`, {
        width: qrSettings.size,
      })
      
      // Upload to media collection
      const mediaDoc = await req.payload.create({
        collection: 'media',
        data: {
          alt: `QR Code for ${doc.name}`,
          caption: `Scan to view event: ${doc.name}`,
        },
        file: {
          path: filePath,
          filename,
          mimetype: 'image/png',
          size: fs.statSync(filePath).size,
        },
      })
      
      // Update event with QR code reference
      await req.payload.update({
        collection: 'events',
        id: doc.id,
        data: {
          qrCodeMediaId: mediaDoc.id,
          qrCodeSettings: {
            ...qrSettings,
            forceRegenerate: false
          }
        },
        // Important: prevent infinite loop by skipping hooks
        hook: false,
      })
      
      // Clean up temporary file
      fs.unlinkSync(filePath)
    } catch (error) {
      console.error('Error generating QR code:', error)
    }
  }
  
  return doc
}
```

## Integration with Collections

Register hooks within your collection configuration:

```typescript
// src/collections/Events/index.ts
import type { CollectionConfig } from 'payload'
import { generateQRCode } from '../../hooks/collections/events/afterChange'

const Events: CollectionConfig = {
  slug: 'events',
  // Collection fields...
  hooks: {
    afterChange: [generateQRCode],
    // Other hooks...
  },
}

export default Events
```

## Best Practices

### 1. Keep Hooks Focused
Each hook should have a single responsibility. Split complex logic into multiple hooks if needed.

### 2. Proper Error Handling
Always use try/catch blocks to prevent a failing hook from disrupting the entire operation.

```typescript
export const myHook = async ({ doc }) => {
  try {
    // Hook logic
  } catch (error) {
    console.error('Hook failed:', error)
    // Decide whether to throw or continue
  }
  return doc
}
```

### 3. Make Hooks Idempotent
Hooks should be safe to run multiple times with the same input.

### 4. Use TypeScript Types
Always leverage Payload's TypeScript types for type safety.

```typescript
import type { BeforeChangeHook } from 'payload'

export const beforeChangeHook: BeforeChangeHook = ({ data }) => {
  // Type-safe hook implementation
  return data
}
```

### 5. Document Your Hooks
Add JSDoc comments explaining hook purpose, side effects, and requirements.

```typescript
/**
 * Generates a slug from the title field when creating or updating a document
 * 
 * @param data - The document data
 * @param operation - The current operation (create/update)
 * @returns The modified data with slug field
 */
export const generateSlug: BeforeChangeHook = ({ data, operation }) => {...}
```

### 6. Use Context to Pass Data Between Hooks
Leverage the context object to pass data between sequential hooks.

```typescript
// First hook
export const firstHook: BeforeChangeHook = ({ data, context }) => {
  return {
    ...data,
    context: {
      ...context,
      customData: 'some value',
    },
  }
}

// Second hook
export const secondHook: BeforeChangeHook = ({ data, context }) => {
  // Access data from first hook
  console.log(context.customData) // 'some value'
  return data
}
```

### 7. Prevent Infinite Loops
When updating documents within afterChange hooks, use `hook: false` to prevent recursion.

```typescript
await payload.update({
  collection: 'collection',
  id: doc.id,
  data: updatedData,
  hook: false, // Prevents triggering hooks again
})
```

### 8. Test Hooks Independently
Create unit tests for hooks to verify behavior in isolation.

## Common Pitfalls to Avoid

1. **Infinite Loops**: Updating the same document from an afterChange hook without `hook: false`
2. **Performance Issues**: Performing heavy operations synchronously
3. **Race Conditions**: Assuming hooks always run in a particular order
4. **Missing Error Handling**: Not catching exceptions in hooks
5. **Side Effects**: Modifying objects passed to hooks without returning them
6. **Complexity Creep**: Creating large monolithic hooks instead of smaller focused ones
7. **Inconsistent State**: Not considering other hooks that might run in the same lifecycle

## Examples by Hook Type

### BeforeChange Example: Auto-Generate Slug

```typescript
import slugify from 'slugify'
import type { BeforeChangeHook } from 'payload'

export const generateSlug: BeforeChangeHook = ({ data, operation }) => {
  if (operation === 'create' || (operation === 'update' && data.title)) {
    data.slug = slugify(data.title, { lower: true })
  }
  return data
}
```

### AfterRead Example: Format Dates

```typescript
import { format } from 'date-fns'
import type { AfterReadHook } from 'payload'

export const formatDates: AfterReadHook = ({ doc }) => {
  if (doc.startDate) {
    doc.formattedStartDate = format(new Date(doc.startDate), 'MMM d, yyyy')
  }
  return doc
}
```

### Field Hook Example: Calculate Price with Tax

```typescript
import type { FieldHook } from 'payload'

export const calculateTotalPrice: FieldHook = ({ value, siblingData }) => {
  if (siblingData.price && siblingData.taxRate) {
    return siblingData.price * (1 + siblingData.taxRate / 100)
  }
  return value
}
``` 